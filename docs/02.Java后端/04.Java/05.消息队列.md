---
title: 消息队列
date: 2020-11-16 21:36:23
permalink: /pages/6b7885/
categories:
  - Java后端
  - Java
tags:
  - 
---
# 消息队列



# **1.关于消息队列**

消息队列，外文名Message Queue，简称MQ，是指在消息的传输中保存消息的容器或服务。

消息队列，是分布式系统实现高性能、高可用、可伸缩等高级特效的重要组件，适用多种场景，如：消息通讯、异步处理、应用解耦、流量削峰等等。

常见的主流消息队列：ActiveMQ、RabbitMQ、RocketMQ和Kafka。

# **2.应用场景**

##  2.1.消息通讯


作为消息队列，其本职场景就是实现消息通讯，

应用举例：微信单人发消息、QQ聊天群等。

消息队列主要有两种模式：点对点（Point to Point）模式和发布-订阅（Publisher-Subscriber）模式。

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190821164015925.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oYW5jaGFvLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70)

点对点模式：

参与者：消息发送者被称为生产者(Producer)，消息容器被称之为队列(queue)、消息接收者被称之为消费者(Consumer)。
每个消息只有一个消费者，一旦被消费，则从队列中移除。
为了让队列移除消息，消费者在消费之后，应该给予队列应答(ACK)。
发布-订阅模式：

参与者：消息发送者被称为发布者(Publisher)，消息容器被称之为话题(topic)、消息接收者被称之为订阅者(Consumer)。
每个消息可有多个订阅者，即使被消费，依然在队列中存在。
为了能消费指定话题的消息，订阅者需要订阅该topic；如果不在需要消费其消息，则取消订阅该topic。

##  **2.2.异步处理**


有时一个操作会涉及多步处理，如果全部同步处理，则耗时很长。

此时，可以将[非关键性业务需要处理]作为消息发送给MQ，然后直接返回操作结果，节省这些业务处理上的耗时。

然后，再通过其他服务异步的消费MQ中的消息，进行非关键性业务的处理。

优点：减低响应时间，提高性能和吞吐量。

应用举例：会员注册之后的短信通知、网站站内信等。

以下图为例：

同步处理：注册流程共耗时=保存用户50ms+短信通知50ms=100ms
异步处理：注册流程共耗时=保存用户50ms+发送消息5ms=55ms

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190821164032706.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oYW5jaGFvLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70)

## **2.3.应用解耦**


有时一个操作会涉及多个服务，如果其中一个服务挂掉，则整个操作不可用。

此时，可以将[非关键性业务需要处理]作为消息发送给MQ，然后直接返回操作结果，无需在意这些业务是否处理成功。

然后，再通过其他服务异步的消费MQ中的消息，进行非关键性业务的处理。

优点：降低应用耦合性，提升服务可用性和稳定性。

以下图为例：

应用耦合的情况下，如果短信服务发送故障，则整个注册功能都将不可用。
应用解耦的情况下，即使短信服务发送故障，注册功能也能继续提供服务。

## ![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190821164044747.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oYW5jaGFvLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70) **2.4.流量削峰**


在秒杀场景，由于峰值访问量过大，超出服务能力，则会压垮服务，导致服务崩溃。

此时，可以先将用户的秒杀请求作为消息存入MQ，然后服务再根据自身能力慢慢处理这些请求。

优点：提示峰值处理能力，提示服务稳定性。

应用举例：秒杀活动、团购抢单等。

以下图为例：

未削峰：秒杀请求峰值为5k，而订单服务的最大吞吐量只有2k，这种情况下定会压垮订单服务。
削峰：秒杀请求峰值为5k，MQ的最大吞吐量为100k，处理这些请求绰绰有余；订单服务以2k的速度处理MQ中的请求，服务不会崩溃。

# ![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190821164055919.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oYW5jaGFvLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70)

# 3.常见消息队列及对比


常见消息队列如下：

RabbitMQ：使用Erlang编写的开源消息队列，在AMQP(高级消息队列协议)基础上完成的，以高性能、健壮以及可伸缩性出名，非常重量级，多用于企业级开发。
ActiveMQ：Apache软件基金会所研发的开源消息队列，使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。
RocketMQ：阿里巴巴的开源消息队列，用 Java 语言实现，在设计时参考了 Kafka。
Kafka：Apache软件基金会的开源消息队列，由Scala和Java编写。

| 对比内容       | RabbitMQ                     | ActiveMQ           | RocketMQ   | Kafka                |
| -------------- | ---------------------------- | ------------------ | ---------- | -------------------- |
| 所属机构/公司  | GoPivotal                    | Apache             | Alibaba    | Apache               |
| 是否开源       | 开源                         | 开源               | 开源       | 开源                 |
| 技术文档完备   | 高                           | 高                 | 高         | 高                   |
| 快速入门       | 提供                         | 提供               | 提供       | 提供                 |
| 成熟度         | 成熟                         | 成熟               | 成熟       | 成熟                 |
| 数据可靠性     | 可靠                         | 可靠               | 可靠       | 可靠                 |
| 集群           | 支持                         | 支持               | 支持       | 支持                 |
| 负载均衡       | 支持                         | 支持               | 支持       | 支持                 |
| 部署方式       | 独立                         | 独立               | 独立       | 独立                 |
| 开发语言       | ErLang                       | Java               | Java       | Scala && Java        |
| 批量操作       | 不支持                       | 支持               | 支持       | 支持                 |
| 有序性支持     | 单客户端有序                 | 支持               | 支持       | 支持                 |
| 管理界面       | 较好                         | 一般               | 命令行界面 | 命令行界面           |
| 消息延时       | 微秒级                       | 微秒级             | 毫秒级     | 毫秒级               |
| 事务支持       | 不支持                       | 支持               | 支持       | 不支持               |
| 客户端支持语言 | 多种                         | 多种               | Java       | 多种                 |
| 社区活跃度     | 高                           | 高                 | 中         | 高                   |
| 商业支持       | 无                           | 无                 | 阿里云     | 无                   |
| 协议支持       | AMQP等多种                   | AMQP等多种         | 自定义协议 | 自有协议,HTTP        |
| 消息丢失概率   | 低                           | 低                 | 无         | 无                   |
| 可用性         | 主从                         | 主从               | 分布式     | 分布式               |
| 单机吞吐量     | 万级                         | 万级               | 十万级     | 十万级               |
| 部署难度       | 低                           | 低                 | 低         | 中                   |
| 持久化         | 内存、文件，数据堆积影响效率 | 内存、文件、数据库 | 磁盘       | 磁盘，`无限数据堆积` |
| 消费方式       | push/pull                    | push/pull          | push/pull  | pull                 |

# 存在的问题

如何保证数据的一致性？分布式事务.

如何保证服务的一致性？ 可用性。